# learn.javascript




## Введение в JavaScript


- изначально создавался для того, чтобы сделать web-странички «живыми»
- программы на этом языке называются скриптами
- JavaScript может выполняться не только в браузере, а где угодно, нужна лишь специальная программа – интерпретатор. Процесс выполнения скрипта называют «интерпретацией». Во все основные браузеры встроен интерпретатор JavaScript, именно поэтому они могут выполнять скрипты на странице.

###### Что может и что не может
- В браузере JavaScript умеет делать всё, что относится к манипуляции со страницей, взаимодействию с посетителем и, в какой-то мере, с сервером
- не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры. JavaScript, работающий в одной вкладке, не может общаться с другими вкладками и окнами, за исключением случая, когда он сам открыл это окно или несколько вкладок из одного источника.

###### Преимущества JavaScript
- Полная интеграция с HTML/CSS.
- Простые вещи делаются просто.
- Поддерживается всеми распространёнными браузерами и включён по умолчанию.

###### Тенденции
- JavaScript становится всё более и более мощным и возможности браузера растут
- JavaScript становится всё быстрее и стабильнее, в язык добавляются новые возможности
- всё идет к полной совместимости со стандартом




## Внешние скрипты, порядок исполнения


###### Синхронная загрузка и выполнение скриптов:

Если скрипт в коде:
Код -> Скрипт -> Код, который ниже

Если скрипт подклеен в head:
Скрипт в ```head``` -> Код в ```body```

Если скриптов несколько - они грузятся по порядку.

Асинхронные скрипты:

```javascript
<script async src="...">
```

Выполняется полностью асинхронно, как скрипт загрузится - так и выполнится. А страница сама по себе грузится.


```javascript
<script defer src="...">
```

Аналогично + 2 отличия:
- Относительный порядок скриптов будет сохранен
- Выполняется, когда загрузится весь html
￼
￼


###### Типы величин

Есть 5 «примитивных» типов: ```number```, ```string```, ```boolean```, ```null```, ```undefined``` и 6-й тип – объекты ```object```.

Оператор ```typeof x``` позволяет выяснить, какой тип находится в x, возвращая его в виде строки.




## Основные операторы

###### Арифметические
```+``` сложение (конкатенация) строк
Если один из аргументов - строка, остальные тоже приведутся к сроке. Другие арифметические операторы приведут к числу.

Унарный + приводит к числу! (‘Побочный эффект’)

```--```, ```++``` декремент и инкремент

```*=```, ```+=``` и тд вызов с присваиванием



###### Операторы сравнения и логические значения

Больше/меньше: ```a > b```, ```a < b```.
Больше/меньше или равно: ```a >= b```, ```a <= b```.
Равно ```a == b```.
«Не равно». Знак равенства с восклицательным знаком перед ним ```!=```.

```===```, ```!==``` Оператор строгого равенства (неравенства)


Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства ```===``` (```!==```)


###### Побитовые операторы

Применение: Маски

Основная сфера применения масок – это быстрые вычисления, экономия памяти, низкоуровневые операции, связанные с рисованием из JavaScript (3d-графика), интеграция с некоторыми функциями ОС (для серверного JavaScript), и другие ситуации, когда уже существуют функции, требующие битовую маску.

Применение: Округление

Битовые операции отбрасывают десятичную часть, то их можно использовать для округления. Достаточно взять любую операцию, которая не меняет значение числа.

Двойное НЕ (```~```)
Исключающее ИЛИ (```^```) с нулём




##### Логические операторы

Принцип короткого цикла вычислений.

```||``` - вычисляется слева направо, до первого ```true```. Остальное в целях экономии не обрабатывается. Возвращает то значение, на котором остановились вычисления.

Если все значения «ложные», то ```||``` возвратит последнее из них.

```||``` запинается на «правде»,
```&&``` запинается на «лжи»

```!НЕ``` - приводит аргумент к логическому типу ```true```/```false```. Затем возвращает противоположное значение.

Двойное НЕ используют для преобразования значений к логическому типу.




## Преобразование типов для примитивов

###### Строковое преобразование

```alert()```
```String()```
Бинарный ```+```


###### Численное преобразование

Математические операторы (кроме бинарного ```+```), операторы сравнения (кроме ```===```)

Унарный ```+```

```Number()```

￼
Если есть буквы в строке - будет ```NaN```


###### Преобразование к логическому значению

В логическом контексте: ```if```, логические операторы

￼
Строка «0», строка из пробелов - ```true```

```!!``` Двойное логическое отрицание
```Boolean()```



## Циклы while, for


###### While and Do ... while

```javascript
while (условие) {
  // код, тело цикла
}
```

```javascript
var i = 0;
while (i < 3) {
  alert( i );
  i++;
}
```

```javascript
var i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

Синтаксис ```do..while``` редко используется, т.к. обычный ```while``` нагляднее.


###### For

```javascript
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```

```javascript
var i;

for (i = 0; i < 3; i++) {
  alert( i );
}
```

Цикл выполняется до тех пор, пока условие верно


###### Break & Continue

```Break``` - выход из цикла

Сочетание «бесконечный цикл + ```break```» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале-конце цикла, а посередине.

```Continue``` - пропускает итерацию




## Функции

*Function Declaration* – функция, объявленная в основном потоке кода.

```javascript
function f(параметры) {
  // тело функции
};
```


*Function Expression* – объявление функции в контексте какого-либо выражения, например присваивания.

```javascript
var f = function(параметры) {
  // тело функции
};
```

Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
(При декларации функция сработает даже есть она описана после вызова).

Это из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти: они не являются частью выражений и начинаются со слова function) и обрабатывает их.

Если функция создается в зависимости от условия, то лучше Function Expression.

Если функция задана как Function Expression, ей можно дать имя.
Оно будет доступно только внутри функции (кроме IE8-).
Это имя предназначено для надёжного рекурсивного вызова функции, даже если она записана в другую переменную (Named Function Expression - NFE).




## Рекурсия

Значение, на котором рекурсия заканчивается, называют *базисом рекурсии*.

Общее количество вложенных вызовов называют *глубиной рекурсии*. В случае со степенью, всего будет n вызовов.

Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на 10000 вложенных вызовов, но некоторые интерпретаторы допускают и больше.

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы, когда ветвление более сложное.




## Методы и свойства


###### Числа
- 12, 12.5
- Шестнадцатеричная система счисления (0хFF)
- Научная форма (1е3, 3е-5)

Три специальных числовых значения

```Infinity``` и ```-Infinity```

```NaN```
Не равно ничему, включая само себя
```isNaN(n)```

Функция ```isFinite(n)``` преобразует аргумент к числу и возвращает true, если это не ```NaN```/```Infinity```/```-Infinity```.

```parseInt()```, ```parseFloat``` - мягкое преобразование в число, «спотыкаются» и останавливаются на первой «ошибке» (для целых и дробных соответственно), для строк которые начинаются с числа
```````````````toString(система счисления) - перевод числа в другую систему счисления (от 2 до 36)

Math.floor - округляет число вниз (3.2 - 3)
```Math.ceil - округляет число вверх (3.2 - 4)
Math.round - округляет до ближайшего целого (3.2 - 3)

(+ побитовые операторы - округлят как Math.
num.toFixed(2) - округление (до 2 знаков после запятой); возвращает результат в виде строки. Но точнее работает Math.round с умножением и делением.

toLocaleString() - красиво форматирует число (пробелы между разрядами и тп)


Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.


